CREATE TABLE IF NOT EXISTS categoria (
    pk_categoria                INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome_categoria              VARCHAR(100) NOT NULL UNIQUE,
    valor_diaria_padrao         NUMERIC(12,2) NOT NULL,
    multa_diaria_atraso         NUMERIC(12,2) NOT NULL,
    CONSTRAINT ck_valor_diaria CHECK (valor_diaria_padrao > 0),
    CONSTRAINT ck_multa_diaria CHECK (multa_diaria_atraso >= 0)
);

CREATE TABLE IF NOT EXISTS equipamento (
    pk_equipamento             INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nome_equipamento           VARCHAR(150) NOT NULL,
    descricao_equipamento      TEXT,
    fk_categoria_id            INT NOT NULL,
    status_equipamento         VARCHAR(20) NOT NULL DEFAULT 'disponivel',
    data_aquisicao             DATE NOT NULL,
    valor_custo                NUMERIC(12,2) NOT NULL,
    quantidade_disponivel      INT NOT NULL DEFAULT 1,
    CONSTRAINT fk_equipamento_categoria FOREIGN KEY (fk_categoria_id)
        REFERENCES categoria(pk_categoria),
    CONSTRAINT ck_status_equipamento CHECK (status_equipamento IN ('disponivel','alugado','manutencao')),
    CONSTRAINT ck_qtd_positiva CHECK (quantidade_disponivel >= 0)
);

CREATE INDEX IF NOT EXISTS idx_equipamento_categoria ON equipamento(fk_categoria_id);

CREATE TABLE IF NOT EXISTS cliente (
    cpf_cnpj_cliente      VARCHAR(20) PRIMARY KEY,
    nome_cliente          VARCHAR(150) NOT NULL,
    telefone_cliente      VARCHAR(25),
    email_cliente         VARCHAR(150),
    CONSTRAINT uq_cliente_email UNIQUE (email_cliente)
);

CREATE INDEX IF NOT EXISTS idx_cliente_cpf_cnpj ON cliente(cpf_cnpj_cliente);

CREATE TABLE IF NOT EXISTS locacao (
    pk_locacao              INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cpf_cnpj_cliente        VARCHAR(20) NOT NULL,
    nome_cliente            VARCHAR(150),
    data_locacao            TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    data_prevista_devolucao DATE NOT NULL,
    data_devolucao_real     DATE,
    valor_total_estimado    NUMERIC(12,2) NOT NULL DEFAULT 0,
    status_locacao          VARCHAR(30) NOT NULL DEFAULT 'aberta',
    CONSTRAINT fk_locacao_cliente FOREIGN KEY (cpf_cnpj_cliente)
        REFERENCES cliente(cpf_cnpj_cliente)
        ON UPDATE CASCADE
        ON DELETE RESTRICT,
    CONSTRAINT ck_status_locacao CHECK (
        status_locacao IN ('aberta','emcurso','devolucao_pendente','concluida','concluida_com_atraso','cancelada')
    )
);

CREATE INDEX IF NOT EXISTS idx_locacao_status ON locacao(status_locacao);

CREATE TABLE IF NOT EXISTS item_locacao (
    fk_locacao_id              INT NOT NULL,
    fk_equipamento_id          INT NOT NULL,
    valor_diaria_negociada     NUMERIC(12,2) NOT NULL,
    dias_estimados             INT NOT NULL,
    CONSTRAINT pk_item_locacao PRIMARY KEY (fk_locacao_id, fk_equipamento_id),
    CONSTRAINT fk_item_locacao_locacao FOREIGN KEY (fk_locacao_id) REFERENCES locacao(pk_locacao),
    CONSTRAINT fk_item_locacao_equipamento FOREIGN KEY (fk_equipamento_id) REFERENCES equipamento(pk_equipamento),
    CONSTRAINT ck_dias CHECK (dias_estimados > 0)
);

CREATE TABLE IF NOT EXISTS devolucao (
    pk_devolucao               INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fk_locacao_id              INT NOT NULL,
    data_devolucao             TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    valor_multa_atraso         NUMERIC(12,2) DEFAULT 0,
    observacoes                TEXT,
    CONSTRAINT fk_devolucao_locacao FOREIGN KEY (fk_locacao_id) REFERENCES locacao(pk_locacao)
);

CREATE TABLE IF NOT EXISTS item_devolucao (
    fk_devolucao_id            INT NOT NULL,
    fk_equipamento_id          INT NOT NULL,
    estado_devolucao           VARCHAR(60) NOT NULL,
    CONSTRAINT pk_item_devolucao PRIMARY KEY (fk_devolucao_id, fk_equipamento_id),
    CONSTRAINT fk_itemdevolucao_devolucao FOREIGN KEY (fk_devolucao_id) REFERENCES devolucao(pk_devolucao),
    CONSTRAINT fk_itemdevolucao_equipamento FOREIGN KEY (fk_equipamento_id) REFERENCES equipamento(pk_equipamento)
);

CREATE TABLE IF NOT EXISTS pagamento (
    pk_pagamento INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    fk_locacao_id INT NOT NULL,
    data_prevista_devolucao DATE,
    data_devolucao_real DATE,
    valor_total_estimado NUMERIC(12,2) DEFAULT 0,
    valor_multa NUMERIC(12,2) DEFAULT 0,
    valor_total NUMERIC(12,2) DEFAULT 0,
    data_pagamento TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    status_pagamento VARCHAR(20) DEFAULT 'pendente',
    CONSTRAINT fk_pagamento_locacao FOREIGN KEY (fk_locacao_id)
        REFERENCES locacao(pk_locacao)
        ON DELETE CASCADE
);

CREATE OR REPLACE FUNCTION preencher_cliente_por_cpf_cnpj()
RETURNS TRIGGER AS $$
DECLARE v_cliente RECORD;
BEGIN
    SELECT cpf_cnpj_cliente, nome_cliente INTO v_cliente
    FROM cliente
    WHERE cpf_cnpj_cliente = NEW.cpf_cnpj_cliente;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Cliente % não encontrado.', NEW.cpf_cnpj_cliente;
    END IF;

    NEW.nome_cliente := v_cliente.nome_cliente;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_preencher_cliente_por_cpf_cnpj ON locacao;
CREATE TRIGGER trg_preencher_cliente_por_cpf_cnpj
BEFORE INSERT ON locacao
FOR EACH ROW EXECUTE FUNCTION preencher_cliente_por_cpf_cnpj();

CREATE OR REPLACE FUNCTION preencher_pagamento_por_locacao()
RETURNS TRIGGER AS $$
DECLARE v_loc RECORD;
BEGIN
    SELECT data_prevista_devolucao, valor_total_estimado
    INTO v_loc
    FROM locacao
    WHERE pk_locacao = NEW.fk_locacao_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Locação % não encontrada.', NEW.fk_locacao_id;
    END IF;

    NEW.data_prevista_devolucao := v_loc.data_prevista_devolucao;
    NEW.valor_total_estimado := v_loc.valor_total_estimado;
    NEW.valor_total := v_loc.valor_total_estimado;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_preencher_pagamento_por_locacao ON pagamento;
CREATE TRIGGER trg_preencher_pagamento_por_locacao
BEFORE INSERT ON pagamento
FOR EACH ROW EXECUTE FUNCTION preencher_pagamento_por_locacao();

CREATE OR REPLACE FUNCTION calcular_pagamento_multa()
RETURNS TRIGGER AS $$
DECLARE
    v_dias_atraso INT;
    v_multa_base NUMERIC(12,2);
    v_multa_final NUMERIC(12,2);
BEGIN
    SELECT GREATEST((NEW.data_devolucao_real - NEW.data_prevista_devolucao), 0)
    INTO v_dias_atraso;

    IF v_dias_atraso = 0 THEN
        UPDATE pagamento
        SET valor_multa = 0,
            valor_total = valor_total_estimado,
            status_pagamento = 'concluido'
        WHERE pk_pagamento = NEW.pk_pagamento;

        UPDATE locacao
        SET status_locacao = 'concluida',
            data_devolucao_real = NEW.data_devolucao_real
        WHERE pk_locacao = NEW.fk_locacao_id;

        RETURN NEW;
    END IF;

    SELECT COALESCE(SUM(cat.multa_diaria_atraso * v_dias_atraso), 0)
    INTO v_multa_base
    FROM item_locacao il
    JOIN equipamento e ON e.pk_equipamento = il.fk_equipamento_id
    JOIN categoria cat ON cat.pk_categoria = e.fk_categoria_id
    WHERE il.fk_locacao_id = NEW.fk_locacao_id;

    v_multa_final := v_multa_base * 1.20;

    UPDATE pagamento
    SET valor_multa = v_multa_final,
        valor_total = valor_total_estimado + v_multa_final,
        status_pagamento = 'concluido'
    WHERE pk_pagamento = NEW.pk_pagamento;

    UPDATE locacao
    SET status_locacao = 'concluida_com_atraso',
        valor_total_estimado = valor_total_estimado + v_multa_final,
        data_devolucao_real = NEW.data_devolucao_real
    WHERE pk_locacao = NEW.fk_locacao_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_calcular_pagamento_multa ON pagamento;
CREATE TRIGGER trg_calcular_pagamento_multa
AFTER INSERT ON pagamento
FOR EACH ROW EXECUTE FUNCTION calcular_pagamento_multa();

CREATE OR REPLACE FUNCTION reduzir_estoque()
RETURNS TRIGGER AS $$
DECLARE v_qtd INT;
BEGIN
    SELECT quantidade_disponivel INTO v_qtd FROM equipamento WHERE pk_equipamento = NEW.fk_equipamento_id FOR UPDATE;

    IF v_qtd IS NULL THEN
        RAISE EXCEPTION 'Equipamento % não encontrado.', NEW.fk_equipamento_id;
    END IF;

    IF v_qtd <= 0 THEN
        RAISE EXCEPTION 'Não há unidades disponíveis para o equipamento %.', NEW.fk_equipamento_id;
    END IF;

    UPDATE equipamento
    SET quantidade_disponivel = quantidade_disponivel - 1
    WHERE pk_equipamento = NEW.fk_equipamento_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_reduzir_estoque ON item_locacao;
CREATE TRIGGER trg_reduzir_estoque
BEFORE INSERT ON item_locacao
FOR EACH ROW EXECUTE FUNCTION reduzir_estoque();


CREATE OR REPLACE FUNCTION repor_estoque()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE equipamento
    SET quantidade_disponivel = quantidade_disponivel + 1
    WHERE pk_equipamento = NEW.fk_equipamento_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_repor_estoque ON item_devolucao;
CREATE TRIGGER trg_repor_estoque
AFTER INSERT ON item_devolucao
FOR EACH ROW EXECUTE FUNCTION repor_estoque();


CREATE OR REPLACE FUNCTION atualizar_valor_locacao()
RETURNS TRIGGER AS $$
DECLARE v_locacao_id INT;
BEGIN
    IF TG_OP = 'DELETE' THEN
        v_locacao_id := OLD.fk_locacao_id;
    ELSE
        v_locacao_id := NEW.fk_locacao_id;
    END IF;

    UPDATE locacao
    SET valor_total_estimado = COALESCE((
        SELECT SUM(valor_diaria_negociada * dias_estimados)
        FROM item_locacao
        WHERE fk_locacao_id = v_locacao_id
    ), 0)
    WHERE pk_locacao = v_locacao_id;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_atualizar_valor_locacao ON item_locacao;
CREATE TRIGGER trg_atualizar_valor_locacao
AFTER INSERT OR UPDATE OR DELETE ON item_locacao
FOR EACH ROW EXECUTE FUNCTION atualizar_valor_locacao();